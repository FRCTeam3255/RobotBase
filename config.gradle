import org.gradle.internal.os.OperatingSystem

ext.createComponentZipTasks = { components, names, base, type, project, func ->
    def stringNames = names.collect {it.toString()}
    def configMap = [:]
    components.each {
        if (it in NativeLibrarySpec && stringNames.contains(it.name)) {
            it.binaries.each {
                if (!it.buildable) return
                def target = nativeUtils.getPublishClassifier(it)
                if (configMap.containsKey(target)) {
                    configMap.get(target).add(it)
                } else {
                    configMap.put(target, [])
                    configMap.get(target).add(it)
                }
            }
        }
    }
    def taskList = []
    def outputsFolder = file("$project.buildDir/outputs")
    configMap.each { key, value ->
        def task = project.tasks.create(base + "-${key}", type) {
            description = 'Creates component archive for platform ' + key
            destinationDirectory = outputsFolder
            classifier = key
            archiveBaseName = '_M_' + base
            duplicatesStrategy = 'exclude'

            from(licenseFile) {
                into '/'
            }

            func(it, value)
        }
        taskList.add(task)

        project.build.dependsOn task

        project.artifacts {
            task
        }
        addTaskToCopyAllOutputs(task)
    }
    return taskList
}

ext.createAllCombined = { list, name, base, type, project ->
    def outputsFolder = file("$project.buildDir/outputs")

    def task = project.tasks.create(base + "-all", type) {
        description = "Creates component archive for all classifiers"
        destinationDirectory = outputsFolder
        classifier = "all"
        archiveBaseName = base
        duplicatesStrategy = 'exclude'

        list.each {
            if (it.name.endsWith('debug')) return
            from project.zipTree(it.archivePath)
            dependsOn it
        }
    }

    project.build.dependsOn task

    project.artifacts {
        task
    }

    return task

}

ext.includeStandardZipFormat = { task, value ->
    value.each { binary ->
        if (binary.buildable) {
            if (binary instanceof SharedLibraryBinarySpec) {
                task.dependsOn binary.tasks.link
                task.from(new File(binary.sharedLibraryFile.absolutePath + ".debug")) {
                    into nativeUtils.getPlatformPath(binary) + '/shared'
                }
                def sharedPath = binary.sharedLibraryFile.absolutePath
                sharedPath = sharedPath.substring(0, sharedPath.length() - 4)

                task.from(new File(sharedPath + '.pdb')) {
                    into nativeUtils.getPlatformPath(binary) + '/shared'
                }
                task.from(binary.sharedLibraryFile) {
                    into nativeUtils.getPlatformPath(binary) + '/shared'
                }
                task.from(binary.sharedLibraryLinkFile) {
                    into nativeUtils.getPlatformPath(binary) + '/shared'
                }
            } else  if (binary instanceof StaticLibraryBinarySpec) {
                task.dependsOn binary.tasks.createStaticLib
                task.from(binary.staticLibraryFile) {
                    into nativeUtils.getPlatformPath(binary) + '/static'
                }
            }
        }
    }
}
